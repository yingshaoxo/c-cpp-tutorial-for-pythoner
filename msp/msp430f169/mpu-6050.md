# MPU-6050

## Introduction

### The Shape of that Chip

The InvenSense MPU-6050 sensor contains a MEMS accelerometer and a MEMS gyro in a single chip.

> MPU: Micro Processor Unit

> MEMS: _Micro Electro Mechanical Systems_

![](../../.gitbook/assets/mpu6050-pinmap.png)

> I2C: Inter-Integrated Circuit

> GY52 or GY521 is Breakout Board. Don't ask me what is Breakout Board, I don't know either.

When this device stays still, the raw value you read from accelerometer or gyro will be a constant value. But when you move that device fast, the accelerometer will return an unstable value compare to the gyro. By the way, they all return x,y,z values.

### I2C \(Inter-Integrated Circuit\)

I²C, pronounced I-squared-C, is a synchronous, multi-master, multi-slave, packet switched, single-ended, serial computer bus invented in 1982 by Philips Semiconductor. It is widely used for attaching lower-speed peripheral ICs to processors and micro-controllers in short-distance, intra-board communication.

![](../../.gitbook/assets/i2c-timing-diagram.jpg)

## Communication Protocol

USART: Universal Synchronous Asynchronous Receiver Transmitter

Here we use `I2C protocol`, it's different than `SPI protocol`.

There has a lot of details about how to configure I2C in `MSP430 User Guide.pdf`. You just have to search keyword like `I2C Mode` to get it.

## I2C code \(Failed to get any data\)

```c
// ***************
// ****************
// SET MPU6050!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//
// SDA(Serial Data): P3.1
// SCL(Serial Clock): P3.3
// if AD0 = VCC, the slave address become 1101001; 0x69 = 01101001
// if AD0 = 0V, the slave address become 1101000; 0x68 = 01101000
//
// ***************
// ****************

//****************************************
// 定义MPU6050内部地址
//****************************************
#define SMPLRT_DIV 0x19   //陀螺仪采样率，典型值：0x07(125Hz)
#define CONFIG 0x1A       //低通滤波频率，典型值：0x06(5Hz)
#define GYRO_CONFIG 0x1B  //陀螺仪自检及测量范围，典型值：0x18(不自检，2000deg/s)
#define ACCEL_CONFIG 0x1C //加速计自检、测量范围及高通滤波频率，典型值：0x01(不自检，2G，5Hz)
#define ACCEL_XOUT_H 0x3B
#define ACCEL_XOUT_L 0x3C
#define ACCEL_YOUT_H 0x3D
#define ACCEL_YOUT_L 0x3E
#define ACCEL_ZOUT_H 0x3F
#define ACCEL_ZOUT_L 0x40
#define TEMP_OUT_H 0x41
#define TEMP_OUT_L 0x42
#define GYRO_XOUT_H 0x43
#define GYRO_XOUT_L 0x44
#define GYRO_YOUT_H 0x45
#define GYRO_YOUT_L 0x46
#define GYRO_ZOUT_H 0x47
#define GYRO_ZOUT_L 0x48
#define PWR_MGMT_1 0x6B //电源管理，典型值：0x00(正常启用)
#define WHO_AM_I 0x75   //IIC地址寄存器(默认数值0x68，只读)

#define SLAVEADDR 0x68;
int tx_count;
int rx_count;
unsigned char I2CBuffer[3];
void Init_IIC(void) {
    //将P3.1和P3.3设置为I2C管脚
    P3SEL = 0x0A;
    //设置P3.1和P3.3管脚的方向
    P3DIR &= ~0x0A;
    //选择为I2C模式
    U0CTL |= I2C + SYNC;
    //禁止I2C模块
    U0CTL &= ~I2CEN;
    //设置I2C为7位地址模式，不使用DMA，
    //字节模式，时钟源为SMCLK，
    //设置成传输模式
    I2CTCTL = I2CTRX + I2CSSEL_2;
    //定义从器件地址
    I2CSA = SLAVEADDR;
    //设置本身的地址
    I2COA = 0x01A5;
    //I2C时钟为SMCLK / 160
    I2CPSC = 159;
    //SCL 高电平为：5 *I2C 时钟
    I2CSCLH = 0x03;
    //SCL 低电平为：5 *I2C 时钟
    I2CSCLL = 0x03;
    //I2C 模块有效
    U0CTL |= I2CEN;
    tx_count = 0;
    rx_count = 0;
}

void I2CWriteInit(void) //对于AT24CXXX的写操作是置成主模式并置位中断使能.
{
    //主(Master)模式
    U0CTL |= MST;
    //传输模式，R/W 为：0
    I2CTCTL |= I2CTRX;
    //清除中断标志
    I2CIFG &= ~TXRDYIFG;
    //发送中断使能
    I2CIE = TXRDYIE;
}

void I2CReadInit(void) {
    //接收模式，R/W 为：1
    I2CTCTL &= ~I2CTRX;
    //接收中断使能
    I2CIE = RXRDYIE;
}

void EEPROM_ByteWrite(unsigned char nAddr, unsigned char nVal) {
    //等待I2C模块完成所有操作 //在选定的地址写入数据.
    while (I2CDCTL & I2CBUSY)
        ;
    //设置地址数据
    I2CBuffer[1] = nAddr;
    //设置数据
    I2CBuffer[0] = nVal;
    //设置缓冲区指针
    tx_count = 1;
    //写数据初始化
    I2CWriteInit(); //设置为主模式
    //发送数据的长度
    //1个控制字节，2个数据字节
    I2CNDAT = 2;
    //开始和停止条件产生
    //开始I2C通信
    I2CTCTL |= I2CSTT + I2CSTP;
    return;
}

unsigned char EEPROM_CurrentAddressRead(void) {
    //等待I2C模块完成所有操作
    while (I2CDCTL & I2CBUSY)
        ;
    //读操作的初始化
    I2CReadInit();
    //主(Master)模式
    U0CTL |= MST;
    //接收1个字节的数据
    I2CNDAT = 1;
    //清除中断标志
    I2CIFG &= ~ARDYIFG;
    //开始接收，产生重新起始和停止条件
    I2CTCTL |= I2CSTT + I2CSTP;
    //等待传输完成
    while ((~I2CIFG) & ARDYIFG)
        ;
    //返回数据
    return I2CBuffer[0];
}

unsigned char EEPROM_RandomRead(unsigned char nAddr) {
    //等待I2C模块完成所有操作
    while (I2CDCTL & I2CBUSY)
        ;
    //设置地址
    I2CBuffer[0] = nAddr;
    //设置缓冲区指针
    tx_count = 0;
    //写操作初始化
    I2CWriteInit();
    //传输数据长度
    //1个控制字节和一个地址数据
    I2CNDAT = 1;
    //清除中断标志
    I2CIFG &= ~ARDYIFG;
    //起始条件产生
    I2CTCTL |= I2CSTT;
    //等待传输完成
    while ((~I2CIFG) & ARDYIFG)
        ;
    //读操作初始化
    I2CReadInit();
    //接收一个字节的数据
    I2CNDAT = 1;
    //清除中断标志
    I2CIFG &= ~ARDYIFG;
    //开始接收，产生重新起始和停止条件
    I2CTCTL |= I2CSTT + I2CSTP;
    //等待传输完成
    while ((~I2CIFG) & ARDYIFG)
        ;
    //返回数据
    return I2CBuffer[0];
}

void EEPROM_AckPolling(void) {
    unsigned int count;
    //等待I2C模块完成所有操作
    while (I2CDCTL & I2CBUSY)
        ;

    count = 0;
    //清除I2CEN位
    U0CTL &= ~I2CEN;
    I2CTCTL |= I2CRM;
    //使能I2C模块
    U0CTL |= I2CEN;
    //设置NACKIFG标志
    I2CIFG = NACKIFG;
    while (NACKIFG & I2CIFG) {
        //清除中断标志
        I2CIFG = 0x00;
        //主(Master)模式
        U0CTL |= MST;
        //设置传输模式
        I2CTCTL |= I2CTRX;
        //产生起始条件
        I2CTCTL |= I2CSTT;

        //等待I2CSTT被清除
        while (I2CTCTL & I2CSTT)
            ;
        //产生停止条件
        I2CTCTL |= I2CSTP;
        //等待停止条件复位
        while (I2CDCTL & I2CBUSY)
            ;
        count = count + 1;
    }

    //清除I2CEN位
    U0CTL &= ~I2CEN;
    I2CTCTL &= ~I2CRM;
    //使能I2C
    U0CTL |= I2CEN;

    return;
}

#pragma vector = USART0TX_VECTOR
__interrupt void ISR_I2C(void) {
    switch (I2CIV) {
    case I2CIV_AL: {
        //仲裁中断
        break;
    }
    case I2CIV_NACK: {
        //NACK中断
        break;
    }
    case I2CIV_OA: {
        //自己地址中断
        break;
    }
    case I2CIV_ARDY: {
        //访问准备好中断
        break;
    }
    case I2CIV_RXRDY: {
        //接收准备好中断
        I2CBuffer[0] = I2CDRB;
        break;
    }
    case I2CIV_TXRDY: {
        //发送准备好中断
        I2CDRB = I2CBuffer[tx_count];
        tx_count = tx_count - 1;
        if (tx_count < 0) {
            //禁止发送中断
            I2CIE &= ~TXRDYIE;
        }
        break;
    }
    case I2CIV_GC: {
        //一般调用中断
        break;
    }
    case I2CIV_STT: {
        //起始条件中断
        break;
    }
    }
}

void Init_IIC_Port(void) {
    //初始化端口寄存器 与IIC口无关的PX口关闭以便于对编写系统板的综合程序.
    //P1DIR = 0xFF;
    //P2DIR = 0xFF;
    P3DIR = 0xF5;
    //P4DIR = 0xFF;
    P5DIR = 0x7F;
    //P6DIR = 0xFF;
    //P4OUT = 0X11;
    //P5OUT &= 0XF0;
    P3SEL |= BIT1 + BIT3; //在这里如果设置成
}

void Init_CLK(void) {
    unsigned int i;
    //将寄存器的内容清零
    //XT2震荡器开启
    //LFTX1工作在低频模式
    //ACLK的分频因子为1
    BCSCTL1 = 0X00;
    do { // 清除OSCFault标志
        IFG1 &= ~OFIFG;
        for (i = 0x20; i > 0; i--)
            ;
    } while ((IFG1 & OFIFG) == OFIFG); // 如果OSCFault =1
    //open XT2, LFTX2 选择低频率
    BCSCTL1 &= ~(XT2OFF + XTS); //BCSCTL1=0X00 功能一样
    //DCO Rsel=7(Freq=3200k/25摄氏度）
    BCSCTL1 |= RSEL0 + RSEL1 + RSEL2;
    BCSCTL1 |= 0x07;
    //MCLK的时钟源为TX2CLK，分频因子为1
    BCSCTL2 += SELM1;
    //SMCLK的时钟源为TX2CLK，分频因子为1
    BCSCTL2 += SELS;
}
//对于系统时钟的选择关系到整个程序运行稳定性.

void initialize_MPU6050() {
    EEPROM_ByteWrite(PWR_MGMT_1, 0x00); //写入数据
    EEPROM_AckPolling();                //等待写操作完成

    EEPROM_ByteWrite(SMPLRT_DIV, 0x07); //写入数据
    EEPROM_AckPolling();                //等待写操作完成

    EEPROM_ByteWrite(CONFIG, 0x06); //写入数据
    EEPROM_AckPolling();            //等待写操作完成

    EEPROM_ByteWrite(GYRO_CONFIG, 0x18); //写入数据
    EEPROM_AckPolling();                 //等待写操作完成

    EEPROM_ByteWrite(ACCEL_CONFIG, 0x01); //写入数据
    EEPROM_AckPolling();                  //等待写操作完成
}

int get_mpu6050_data_by_address(unsigned char register_address) { //合成数据
    unsigned char H, L;
    H = EEPROM_RandomRead(register_address);
    L = EEPROM_RandomRead(register_address + 1);
    return (H << 8) + L;
}

void main(void) {
    WDTCTL = WDTPW + WDTHOLD;

    //initialize_LCD();

    //初始化端口
    Init_IIC_Port();

    //初始化时钟
    Init_CLK();
    //I2C初始化
    Init_IIC(); //置传输方式及控制方式

    //打开中断
    _EINT();

    millisecond_of_delay(150);
    initialize_MPU6050();
    millisecond_of_delay(150);

    while (1) {
        //print_number(0, 1, get_mpu6050_data_by_address(ACCEL_XOUT_H));

        millisecond_of_delay(500);
    }
}
```

It's just too hard. So I just gave up using I2C protocol.

So let's use  \`WitMotion WT61 High-Accuracy 6-Axis MPU6050 TTL Acceleration Sensor\`, it happens to support **UART\(**Universal Asynchronous Receiver/Transmitter**\)**

## References:

{% embed url="https://www.invensense.com/products/motion-tracking/6-axis/mpu-6050/" %}

{% embed url="https://playground.arduino.cc/Main/MPU-6050/" %}

{% embed url="https://www.teachmemicro.com/i2c-primer/" %}



